## 第六章
### 通过Vuex进行状态管理

到本书的该章节为止，所有的数据都存在组件（components）中。我们调用一个API，然后将返回的数据保存在数据对象中。我们将一个表单绑定在一个对象上，并且将该对象保存在数据对象中。组件之间所有的通信都是通过事件（events，从子组件到父组件）和属性（props， 从父组件到子组件）完成的。对于简单的应用来说，这种方式很不错，但是对于复杂的应用来说，这种方式并不高效。

让我们来看一个特殊的消息社交网络应用。你希望在该应用的顶部导航栏有一个图标展示你的消息数量，与此同时，你也希望在页面的底部有个弹窗来显示消息数量。这两个组件在页面中并不相邻，因此要把它们通过事件和属性联系起来简直就是噩梦：对于消息通知完全不相关的两个组件，必须要能知道传入到组件内部的事件。可选的方案是，你可以在每个组件内发起不同的API请求。但是这个方案可能更加糟糕！每一个组件会在不同的时间点更新，这意味着这些组件会显示不同的数据，并且这个页面会发起更多并不需要的API请求。

vuex是一个用来帮助开发者在Vue应用中进行状态管理的库。在你的应用中的任何位置，你都可以使用它提供的中心store来进行存储和使用全局状态。并且让你可以验证传入的数据以此来保证再次传出的数据是可预测并且正确的。

### 安装

你可以通过CDN来使用vuex，只需要添加下面的代码：

```
<script src="https://unpkg.com/vuex"></script>
```

另外，如果你使用的是npm，你可以通过`npm install --save vuex`来进行安装。如果你使用了打包工具，比如webpack，那么就像使用`vue-router`那样，你需要调用`Vue.use()`。

```
    import Vue from 'vue';
    import Vuex from 'vuex';
    Vue.use(Vuex);
```

然后，你需要设置你的store。创建下面的文件并保存到**store/index.js**中：

```
    import Vuex from 'vuex';
    export default new Vuex.Store({
        state: {}
    });
```
目前为止，这只是一个空的store：我们会在该章节里逐渐往里添加内容。
然后，在创建Vue实例时，在你的主应用文件中以属性的方式引入该store:

```
    import Vue from 'vue';
    import store from './store';
    new Vue({
        el: '#app',
        store,
        components: {
            App
        }
    });
```
现在，你已经将该store添加到了你的应用中，并且可以通过`this.$store`来访问它。让我们一起来了解vuex的概念以及你可以通过`this.$store`来做哪些事情。

### 概念

正如该章节中的引用中提到的那样，当一个复杂的应用需要多个组件共享状态时，就要用到vuex了。
让我们来看一个没有使用vuex的简单的组件，这个组件用来显示用户在该页面中的消息数量：

```
    const NotificationCount = {
        template: `<p>Messages: {{ messageCount }}</p>`,
        data: () => ({
            messageCount: 'loading'
        }),
        mounted() {
            const ws = new WebSocket('/api/messages');

            ws.addEventListener('message', (e) => {
                const data = JSON.parse(e.data);
                this.messageCount = data.messages.length;
            });
        }
    };
```

这个组件很简单。开启了指向**/api/messages**的websocket(网络套接字),当服务器将数据传输到客户端时，在这种情况下，当socket开启时（页面上显示初始的消息数），当数量更新时（接收到新的消息）——通过socket发送过来的消息数量会被计算出来，并显示到页面上。


![Tips](./images-[温浪]/tips.png) 在实际运用中，代码会更加复杂：这个例子中没有websocket的认证，并且总是假定通过websocket返回的是有效的JSON数据，该数据中包含类型为数组的message属性，然而事实上并非如此。在这个例子中，这段简单的代码会完成这项工作。

当我们在同一个页面使用多个消息通知组件时，就会遇到问题。因为每个组件会开启一个websocket,这会创建重复的不必要的连接。并且由于网络的延迟，这些组件的更新时间点会稍有不同。为了解决这个问题，可以将websocket的相关逻辑转移到vuex中。

让我们深入剖析一个例子。组件会变成这样：

```
    const NotificationCount = {
        template: `<p>Messages: {{ messageCount }}</p>`,
        computed: {
            messageCount() {
                return this.$store.state.messages.length;
            }
        },
        mounted() {
            this.$store.dispatch('getMessages');
        }
    };
```
接下来是vuex的store：

```
    let ws;
    export default new Vuex.Store({
        state: {
            messages: [],
        },
        mutations: {
            setMessages(state, messages) {
                state.messages = messages;
            }
        },
        actions: {
            getMessages({ commit }) {
                if (ws) {
                    return;
                }
                ws = new WebSocket('/api/messages');
                ws.addEventListener('message', (e) => {
                    const data = JSON.parse(e.data);
                    commit('setMessages', data.messages);
                });
            }
        }
    });
```
现在，每一个挂载完毕的消息通知组件将会触发getMessages，但是在actions检查了websocket是否已经存在，并且只要当一个都不存在时才会创建连接。然后会监听socket套接字，由于store跟vue中大多数东西一样是反应式的，当变化提交到state中时，消息通知组件中的state会被更新。当socket下发新的东西时，全局的store会被更新，并且该页面中所有的组件会被同时更新。

在接下来的章节中，将会介绍你在这个例子中看到的单独的概念——状态（state），变化（mutations），和行为（actions）——并且会讲解一种在大型应用中创建vuex模型的方式来避免生成一个巨大无比混乱不堪的文件。

### 状态和状态助手

首先，让我们来了解状态（state）。状态（state）表示数据是如何保存在vuex store中的。它就像我们可以在应用的任何地方都可以访问到的一个巨大的对象——它是真理的唯一来源。
让我们了解一个只包含一个数字的简单的store：
```
import Vuex from 'vuex';
export default new Vuex.Store({
    state: {
        messageCount: 10
    }
});
```
